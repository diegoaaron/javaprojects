Para declarar una cadena podemos hacerlo con:
String name = "Fluffy";
String name = new String("Fluffy");
string name = """
    Fluffy""";

Al ser un string una secuencia de caracteres este es una implementación de la interfaz CharSequence.

concatenacion: consiste en la unión de cadenas y tiene las siguientes reglas:
- si ambos operadores son numericos "+" significa adicion
- si ambos operadores son cadenas "+" significa concatenacion
- las expresiones se evaluan de izquierda a derecha

System.out.println(1 + 2); //3
System.out.println("a" + "b"); //ab
System.out.println("a" + "b" + 3); //ab3
System.out.println(1 + 2 + "c"); //3c
System.out.println("c" + 1 + 2); //c12
System.out.println("c" + null); //cnull


int a1 = 3;
String a2  = "4";
System.out.println(1 + 2 + a1 + a2); //64

var s = "1"; // s = "1"
s += "2"; // s = "12"
s += 3; // s = "123"

Debemos tener en claro que String tiene muchos metodos y que Java lo considera una secuencia de caracteres y a su vez es inmutable, esto significa que no puede ser modificado despues de creado por lo cual el uso de cualquier metodo creara un nuevo objeto String con el resultado.

calculando el tamaño de la adena on "length()"

var name = "animals";
System.out.println(name.length()); //7

obteniendo un unico caracter con "charAt()"

var name = "animals";
System.out.println(name.charAt(0)); //a

cuando se pasa un indice que no existe en la cadena este devuelve una excepcion

encontrando un indice con "indexOf()", este busca el primer indice que coincida con el caracter o cadena indicada. ya que un char puede ser pasado como un numero tambien podemos ver este tipo de parametros pero en el examen siempre lo asocian con un parametro denominado "ch". los posibles parametros de este metodo son:

public int indexOf(int ch)
public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)

ejemplo:

var name = "animals";

System.out.println(name.indexOf('a')); // 0
System.out.println(name.indexOf('al')); // 4
System.out.println(name.indexOf('a',4)); // 4
System.out.println(name.indexOf('al',5)); // -1

obteniendo una subcadena con el metodo "substring()" en el cual marcamos hasta donde extraeremos la cadena sin contar la posicion final. se puede indicar el parametro inicial o final o solo el final.

public int substring(inicio, final)

var name = "animals";
System.out.println(name.substring(3));   // mals
System.out.println(name.substring(name.indexOf('m'))); // mals
System.out.println(name.substring(3, 4));  // m
System.out.println(name.substring(3, 7));  // mals
System.out.println(name.substring(3, 3));  // vacio
System.out.println(name.substring(3, 2));  // excepcion

tambien tenemos los metodos "toLowerCase()" que convierte todo el texto a minusculas y "toUpperCase()" que lo hace a mayusculas

var name = "animals";
System.out.println(name.toUpperCase());   // ANIMALS
System.out.println("Abc123".toLowerCase());   // abc123


El método equals() verifica si dos objetos de tipo String contienen exactamente los mismos caracteres en el mismo orden. Por otro lado, el método equalsIgnoreCase() hace lo mismo, pero ignora si los caracteres están en mayúsculas o minúsculas.

public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)

System.out.println("abc".equals("ABC"));   // false
System.out.println("abc".equalsIgnoreCase("ABC")); // true

Sobrescribiendo toString(), equals(Object) y hashCode()

Saber cómo sobrescribir correctamente estos métodos es fundamental en Java. Aunque ya no es un requisito obligatorio para las certificaciones, sigue siendo una práctica esencial para cualquier desarrollador Java.

- toString(): Se invoca cuando intentas imprimir un objeto o concatenarlo con una cadena. Generalmente se sobrescribe para proporcionar una descripción única del objeto basada en sus atributos.

- equals(Object): Se utiliza para comparar objetos. La implementación por defecto simplemente compara las referencias, pero es común sobrescribirla para realizar comparaciones más significativas basadas en los atributos del objeto.

- hashCode(): Siempre que sobrescribas equals(Object), debes sobrescribir hashCode() de manera consistente. Esto significa que si a.equals(b) es verdadero, entonces a.hashCode() == b.hashCode() también debe ser verdadero.

A menudo, necesitas buscar dentro de una cadena más larga para determinar si una subcadena está contenida en ella. Los métodos startsWith() y endsWith() verifican si el valor proporcionado coincide con el inicio o el final de la cadena. El método contains() es menos específico; busca coincidencias en cualquier parte de la cadena.


public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)

System.out.println("abc".startsWith("a"));   // true
System.out.println("abc".startsWith("A"));   // false
System.out.println("abc".endsWith("c"));    // true
System.out.println("abc".endsWith("a"));    // false
System.out.println("abc".contains("b"));   // true
System.out.println("abc".contains("B"));   // false

El método replace() realiza una búsqueda y reemplazo simple en la cadena. Existe una versión que acepta caracteres como parámetros y otra que acepta secuencias de caracteres. Las firmas de los métodos son las siguientes:

public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)

System.out.println("abcabc".replace('a', 'A')); // AbcAbc
System.out.println("abcabc".replace("a", "A")); // AbcAbc

Primer ejemplo: Aquí, reemplazamos todas las ocurrencias del carácter 'a' por 'A'. utiliza el reemplazo por caracter
Segundo ejemplo: En este caso, reemplazamos todas las ocurrencias de la subcadena "a" por "A". aqui utilizamos el reemplazo por cadena de caracteres

eliminación de espacios en blanco: Estos métodos se utilizan para eliminar los espacios en blanco al principio y/o al final de una cadena. Los espacios en blanco incluyen espacios, tabulaciones (\t) y saltos de línea (\n).

public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()

- strip(): Elimina todos los espacios en blanco al principio y al final de la cadena.
- stripLeading(): Elimina los espacios en blanco al principio de la cadena.
- stripTrailing(): Elimina los espacios en blanco al final de la cadena.
- trim(): Es similar a strip(), pero no admite todos los caracteres Unicode.

obs: por ejemplo un caracter Unicode que representa un espacio es char ch = '\u2000';

System.out.println("  abc  ".strip());  // abc
System.out.println("\t abc\n".strip()); // abc

String text = " abc\t";
System.out.println(text.trim().length()); // 3
System.out.println(text.strip().length()); // 3
System.out.println(text.stripLeading().length()); // 5
System.out.println(text.stripTrailing().length()); // 4

obs: \t: Representa un carácter de tabulación.

indent(): Agrega un número específico de espacios al inicio de cada línea. Si se pasa un número negativo, intenta eliminar esa cantidad de espacios.

stripIndent(): Elimina la sangría inicial de cada línea.
Normalización de espacios en blanco:

El método indent() también normaliza los espacios en blanco. Esto significa que: Se agrega un salto de línea al final de la cadena si no existe.
Todos los saltos de línea se convierten al formato estándar \n.


El método stripIndent() es útil cuando una cadena se ha construido concatenando partes más pequeñas en lugar de usar un bloque de texto. Este método elimina todos los espacios en blanco adicionales al principio de cada línea. Esto significa que todas las líneas que contienen texto se alinean al principio, eliminando la misma cantidad de espacios en blanco al inicio de cada una, y asegurando que el primer carácter de cada línea no sea un espacio en blanco. Al igual que indent(), convierte los saltos de línea (\r\n) en el formato estándar (\n). Sin embargo, a diferencia de indent(), stripIndent() no agrega un salto de línea al final si falta."

imagen01 -> reglas de indent() y stripIndent()

var block = """
      a
      b
      c""";
var concat = " a\n"
     + "b\n"
     + "c";

System.out.println(block.length()); // 6
System.out.println(concat.length()); // 9
System.out.println(block.indent(1).length()); // 10
System.out.println(concat.indent(-1).length()); // 7
System.out.println(concat.indent(-4).length()); // 6
System.out.println(concat.stripIndent().length()); // 6

Traduciendo Escapes:
Cuando escapamos caracteres, usamos una sola barra invertida. Por ejemplo, \t es un tabulador. Si no queremos este comportamiento, agregamos otra barra invertida para escapar la barra invertida, por lo que \t es la cadena literal \t. El método translateEscapes() toma estos literales y los convierte en el carácter escapado equivalente. La firma del método es la siguiente:

public String translateEscapes()

var str = "1\\t2";
System.out.println(str);           // 1\t2
System.out.println(str.translateEscapes()); // 1  2

este metodo permite esapar \t (tab), \n (nueva linea), \s (esapcio) \" (comillas dobles) y \" (comilla simple)

revisión de cadenas blancas y vacias:
Java proporciona métodos de conveniencia para comprobar si una String tiene una longitud de cero o contiene solo caracteres de espacio en blanco. Las firmas de los métodos son las siguientes:

public boolean isEmpty()
public boolean isBlank()

System.out.println(" ".isEmpty()); // false - tiene un espacio en blanco
System.out.println("".isEmpty()); // true - no hay ningun caracter
System.out.println(" ".isBlank()); // true - no hay caracteres ademas del espacio en blanco.
System.out.println("".isBlank()); // true - no hay caracteres ademas del espacio en blanco.

Formateando Valores:
Hay métodos para formatear valores String usando banderas de formateo. Dos de los métodos toman la cadena de formato como parámetro, y el otro usa una instancia para ese valor.

Los parámetros del método se utilizan para construir una String formateada en una sola llamada al método, en lugar de hacerlo mediante muchas operaciones de formato y concatenación. Devuelven una referencia a la instancia sobre la que se llaman para que las operaciones se puedan encadenar juntas. Las firmas de los métodos son las siguientes:

public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)

var name = "Kate";
var orderId = 5;

// Todos imprimen: Hello Kate, order 5 is ready

System.out.println("Hello "+name+", order "+orderId+" is ready");
System.out.println(String.format("Hello %s, order %d is ready",
    name, orderId));
System.out.println("Hello %s, order %d is ready"
    .formatted(name, orderId));

En las operaciones format() y formatted(), los parámetros se insertan y formatean mediante símbolos en el orden en que se proporcionan en el Vargs.

Formateo comunes:

%s Se aplica a cualquier tipo, comúnmente valores String
%d Se aplica a valores enteros como int y long
%f Se aplica a valores de punto flotante como float y double
%n Inserta un salto de línea usando el separador de línea dependiente del sistema

var name = "James";
var score = 90.25;
var total = 100;

System.out.println("%s:%n Score: %f out of %d".formatted(name, score, total));

la salida es:

James:
Score: 90.250000 out of 100


La mezcla de tipos de datos puede causar excepciones en tiempo de ejecución. Por ejemplo, lo siguiente lanza una excepción porque se usa un número de punto flotante cuando se espera un valor entero:

var str = "Food: %d tons".formatted(2.0);
IllegalFormatConversionException

las banderas ya definidas se pueden ajustar mas; En el ejemplo anterior, el número de punto flotante se imprimió como 90.250000. Por defecto, %f muestra exactamente seis dígitos después del decimal. Si deseas mostrar solo un dígito después del decimal, puedes usar %.1f en lugar de %f. El método format() se basa en el redondeo en lugar de truncar al acortar números.

Por ejemplo, 90.250000 se mostrará como 90.3 (no 90.2) cuando se pase a format() con %.1f.
El método format() también admite dos características adicionales. Puedes especificar la longitud total de la salida usando un número antes del símbolo decimal. Por defecto, el método rellenará el espacio vacío con espacios en blanco. También puedes rellenar el espacio vacío con ceros colocando un solo cero antes del símbolo decimal. Los siguientes ejemplos usan corchetes, [], para mostrar el inicio/fin del valor formateado:

var pi = 3.141592653589;
System.out.format("[%6f]",pi);    // [3.141593]
System.out.format("[%12.8f]",pi);  // [ 3.14159265]
System.out.format("[%012f]",pi);   // [00003.141593]
System.out.format("[%12.2f]",pi);  // [       3.14]
System.out.format("[%.3f]",pi);    // [3.142]

Encadenamiento de Métodos:

var start = "AniMaL ";
var trimmed = start.trim();        // "AniMaL"
var lowercase = trimmed.toLowerCase(); // "animal"
var result = lowercase.replace('a', 'A'); // "AnimAl"
System.out.println(result);

Esto es solo una serie de métodos String. Cada vez que se llama a uno, el valor devuelto se coloca en una nueva variable. Hay cuatro valores String a lo largo del camino, y se muestra AnimAl como salida.
Sin embargo, en el examen, hay una tendencia a comprimir tanto código como sea posible en un espacio pequeño. Verás código usando una técnica llamada "encadenamiento de métodos". Aquí hay un ejemplo:

String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result);

Este código es equivalente al ejemplo anterior. También crea cuatro objetos String y muestra AnimAl. Para leer código que usa encadenamiento de métodos, empieza por la izquierda y evaluar el primer método. Luego llamar al siguiente método sobre el valor devuelto por el primer método. Continúa así hasta que llegues al punto y coma.

5: String a = "abc";
6: String b = a.toUpperCase();
7: b = b.replace("B", "2").replace('C', '3');
8: System.out.println("a=" + a);
9: System.out.println("b=" + b);

En la línea 5, establecemos que a apunte a "abc" y nunca apuntó a nada más. Como ninguno del código en las líneas 6 y 7 cambia a, el valor permanece "abc".
Sin embargo, b es un poco más complicado. La línea 6 hace que b apunte a "ABC", lo cual es sencillo. En la línea 7, tenemos encadenamiento de métodos. Primero se llama a "ABC".replace("B", "2"). Esto devuelve "A2C". Luego, se llama a "A2C".replace('C', '3'), lo que devuelve "A23".

Usando la Clase StringBuilder:

10: String alpha = "";
11: for(char current = 'a'; current <= 'z'; current++)
12:   alpha += current;
13: System.out.println(alpha);

La String vacía en la línea 10 se instancia, y luego la línea 12 añade una "a". Sin embargo, como el objeto String es inmutable, se asigna un nuevo objeto String a alpha, y el objeto "" se vuelve elegible para la recolección de basura.
La siguiente vez que se pasa por el bucle, alpha se asigna a un nuevo objeto String "ab", y el objeto "a" se vuelve elegible para la recolección de basura.
La siguiente iteración asigna alpha a "abc", y el objeto "ab" se vuelve elegible para la recolección de basura, y así sucesivamente.

Esta secuencia de eventos continúa, y después de 26 iteraciones a través del bucle, un total de 27 objetos son instanciados, la mayoría de los cuales son inmediatamente elegibles para la recolección de basura.

Esto es muy ineficiente. Afortunadamente, Java tiene una solución. La clase StringBuilder crea una String sin almacenar todos esos valores String intermedios. A diferencia de la clase String, StringBuilder no es inmutable.

15: StringBuilder alpha = new StringBuilder();
16: for(char current = 'a'; current <= 'z'; current++)
17:  alpha.append(current);
18: System.out.println(alpha);

En la línea 15, se instancia un nuevo objeto StringBuilder. La llamada a append() en la línea 17 añade un carácter al objeto StringBuilder cada vez que pasa por el bucle for, añadiendo el valor de current al final de alpha. Este código reutiliza el mismo StringBuilder sin crear una String intermedia cada vez.

Mutabilidad y Encadenamiento:

Seguramente notaste esto del ejemplo anterior, pero StringBuilder no es inmutable. De hecho, le dimos 27 valores diferentes en el ejemplo (un espacio en blanco más cada letra del alfabeto). El examen probablemente intentará engañarte con respecto a la mutabilidad de String y StringBuilder.

El encadenamiento hace esto aún más interesante. Cuando encadenamos llamadas a métodos String, el resultado era una nueva String con la respuesta. El encadenamiento de métodos StringBuilder no funciona así. En su lugar, el StringBuilder cambia su propio estado y devuelve una referencia a sí mismo. Veamos un ejemplo para aclarar esto:

4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle"); // sb = "start+middle"
6: StringBuilder same = sb.append("+end"); // "start+middle+end"

La línea 5 añade texto al final de sb. También devuelve una referencia a sb, que se ignora. La línea 6 también añade texto al final de sb y devuelve una referencia a sb. Esta vez la referencia se almacena en same. Esto significa que sb y same apuntan al mismo objeto e imprimirían el mismo valor.

El examen no siempre hará que el código sea fácil de leer teniendo solo un método por línea. ¿Qué crees que imprime este ejemplo?

4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);

¿Dijiste que ambos imprimen "abcdefg"? Bien. Solo hay un objeto StringBuilder aquí. Sabemos eso porque new StringBuilder() se llama solo una vez. En la línea 5,


