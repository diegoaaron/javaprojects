Para declarar una cadena podemos hacerlo con:
String name = "Fluffy";
String name = new String("Fluffy");
string name = """
    Fluffy""";

Al ser un string una secuencia de caracteres este es una implementación de la interfaz CharSequence.

concatenacion: consiste en la unión de cadenas y tiene las siguientes reglas:
- si ambos operadores son numericos "+" significa adicion
- si ambos operadores son cadenas "+" significa concatenacion
- las expresiones se evaluan de izquierda a derecha

System.out.println(1 + 2); //3
System.out.println("a" + "b"); //ab
System.out.println("a" + "b" + 3); //ab3
System.out.println(1 + 2 + "c"); //3c
System.out.println("c" + 1 + 2); //c12
System.out.println("c" + null); //cnull


int a1 = 3;
String a2  = "4";
System.out.println(1 + 2 + a1 + a2); //64

var s = "1"; // s = "1"
s += "2"; // s = "12"
s += 3; // s = "123"

Debemos tener en claro que String tiene muchos metodos y que Java lo considera una secuencia de caracteres y a su vez es inmutable, esto significa que no puede ser modificado despues de creado por lo cual el uso de cualquier metodo creara un nuevo objeto String con el resultado.

calculando el tamaño de la adena on "length()"

var name = "animals";
System.out.println(name.length()); //7

obteniendo un unico caracter con "charAt()"

var name = "animals";
System.out.println(name.charAt(0)); //a

cuando se pasa un indice que no existe en la cadena este devuelve una excepcion

encontrando un indice con "indexOf()", este busca el primer indice que coincida con el caracter o cadena indicada. ya que un char puede ser pasado como un numero tambien podemos ver este tipo de parametros pero en el examen siempre lo asocian con un parametro denominado "ch". los posibles parametros de este metodo son:

public int indexOf(int ch)
public int indexOf(int ch, int fromIndex)
public int indexOf(String str)
public int indexOf(String str, int fromIndex)

ejemplo:

var name = "animals";

System.out.println(name.indexOf('a')); // 0
System.out.println(name.indexOf('al')); // 4
System.out.println(name.indexOf('a',4)); // 4
System.out.println(name.indexOf('al',5)); // -1

obteniendo una subcadena con el metodo "substring()" en el cual marcamos hasta donde extraeremos la cadena sin contar la posicion final. se puede indicar el parametro inicial o final o solo el final.

public int substring(inicio, final)

var name = "animals";
System.out.println(name.substring(3));   // mals
System.out.println(name.substring(name.indexOf('m'))); // mals
System.out.println(name.substring(3, 4));  // m
System.out.println(name.substring(3, 7));  // mals
System.out.println(name.substring(3, 3));  // vacio
System.out.println(name.substring(3, 2));  // excepcion

tambien tenemos los metodos "toLowerCase()" que convierte todo el texto a minusculas y "toUpperCase()" que lo hace a mayusculas

var name = "animals";
System.out.println(name.toUpperCase());   // ANIMALS
System.out.println("Abc123".toLowerCase());   // abc123


El método equals() verifica si dos objetos de tipo String contienen exactamente los mismos caracteres en el mismo orden. Por otro lado, el método equalsIgnoreCase() hace lo mismo, pero ignora si los caracteres están en mayúsculas o minúsculas.

public boolean equals(Object obj)
public boolean equalsIgnoreCase(String str)

System.out.println("abc".equals("ABC"));   // false
System.out.println("abc".equalsIgnoreCase("ABC")); // true

Sobrescribiendo toString(), equals(Object) y hashCode()

Saber cómo sobrescribir correctamente estos métodos es fundamental en Java. Aunque ya no es un requisito obligatorio para las certificaciones, sigue siendo una práctica esencial para cualquier desarrollador Java.

- toString(): Se invoca cuando intentas imprimir un objeto o concatenarlo con una cadena. Generalmente se sobrescribe para proporcionar una descripción única del objeto basada en sus atributos.

- equals(Object): Se utiliza para comparar objetos. La implementación por defecto simplemente compara las referencias, pero es común sobrescribirla para realizar comparaciones más significativas basadas en los atributos del objeto.

- hashCode(): Siempre que sobrescribas equals(Object), debes sobrescribir hashCode() de manera consistente. Esto significa que si a.equals(b) es verdadero, entonces a.hashCode() == b.hashCode() también debe ser verdadero.

A menudo, necesitas buscar dentro de una cadena más larga para determinar si una subcadena está contenida en ella. Los métodos startsWith() y endsWith() verifican si el valor proporcionado coincide con el inicio o el final de la cadena. El método contains() es menos específico; busca coincidencias en cualquier parte de la cadena.


public boolean startsWith(String prefix)
public boolean endsWith(String suffix)
public boolean contains(CharSequence charSeq)

System.out.println("abc".startsWith("a"));   // true
System.out.println("abc".startsWith("A"));   // false
System.out.println("abc".endsWith("c"));    // true
System.out.println("abc".endsWith("a"));    // false
System.out.println("abc".contains("b"));   // true
System.out.println("abc".contains("B"));   // false

El método replace() realiza una búsqueda y reemplazo simple en la cadena. Existe una versión que acepta caracteres como parámetros y otra que acepta secuencias de caracteres. Las firmas de los métodos son las siguientes:

public String replace(char oldChar, char newChar)
public String replace(CharSequence target, CharSequence replacement)

System.out.println("abcabc".replace('a', 'A')); // AbcAbc
System.out.println("abcabc".replace("a", "A")); // AbcAbc

Primer ejemplo: Aquí, reemplazamos todas las ocurrencias del carácter 'a' por 'A'. utiliza el reemplazo por caracter
Segundo ejemplo: En este caso, reemplazamos todas las ocurrencias de la subcadena "a" por "A". aqui utilizamos el reemplazo por cadena de caracteres

eliminación de espacios en blanco: Estos métodos se utilizan para eliminar los espacios en blanco al principio y/o al final de una cadena. Los espacios en blanco incluyen espacios, tabulaciones (\t) y saltos de línea (\n).

public String strip()
public String stripLeading()
public String stripTrailing()
public String trim()

- strip(): Elimina todos los espacios en blanco al principio y al final de la cadena.
- stripLeading(): Elimina los espacios en blanco al principio de la cadena.
- stripTrailing(): Elimina los espacios en blanco al final de la cadena.
- trim(): Es similar a strip(), pero no admite todos los caracteres Unicode.

obs: por ejemplo un caracter Unicode que representa un espacio es char ch = '\u2000';

System.out.println("  abc  ".strip());  // abc
System.out.println("\t abc\n".strip()); // abc

String text = " abc\t";
System.out.println(text.trim().length()); // 3
System.out.println(text.strip().length()); // 3
System.out.println(text.stripLeading().length()); // 5
System.out.println(text.stripTrailing().length()); // 4

obs: \t: Representa un carácter de tabulación.

indent(): Agrega un número específico de espacios al inicio de cada línea. Si se pasa un número negativo, intenta eliminar esa cantidad de espacios.

stripIndent(): Elimina la sangría inicial de cada línea.
Normalización de espacios en blanco:

El método indent() también normaliza los espacios en blanco. Esto significa que: Se agrega un salto de línea al final de la cadena si no existe.
Todos los saltos de línea se convierten al formato estándar \n.


El método stripIndent() es útil cuando una cadena se ha construido concatenando partes más pequeñas en lugar de usar un bloque de texto. Este método elimina todos los espacios en blanco adicionales al principio de cada línea. Esto significa que todas las líneas que contienen texto se alinean al principio, eliminando la misma cantidad de espacios en blanco al inicio de cada una, y asegurando que el primer carácter de cada línea no sea un espacio en blanco. Al igual que indent(), convierte los saltos de línea (\r\n) en el formato estándar (\n). Sin embargo, a diferencia de indent(), stripIndent() no agrega un salto de línea al final si falta."

imagen01 -> reglas de indent() y stripIndent()

var block = """
      a
      b
      c""";
var concat = " a\n"
     + "b\n"
     + "c";

System.out.println(block.length()); // 6
System.out.println(concat.length()); // 9
System.out.println(block.indent(1).length()); // 10
System.out.println(concat.indent(-1).length()); // 7
System.out.println(concat.indent(-4).length()); // 6
System.out.println(concat.stripIndent().length()); // 6

Traduciendo Escapes:
Cuando escapamos caracteres, usamos una sola barra invertida. Por ejemplo, \t es un tabulador. Si no queremos este comportamiento, agregamos otra barra invertida para escapar la barra invertida, por lo que \t es la cadena literal \t. El método translateEscapes() toma estos literales y los convierte en el carácter escapado equivalente. La firma del método es la siguiente:

public String translateEscapes()

var str = "1\\t2";
System.out.println(str);           // 1\t2
System.out.println(str.translateEscapes()); // 1  2

este metodo permite esapar \t (tab), \n (nueva linea), \s (esapcio) \" (comillas dobles) y \" (comilla simple)

revisión de cadenas blancas y vacias:
Java proporciona métodos de conveniencia para comprobar si una String tiene una longitud de cero o contiene solo caracteres de espacio en blanco. Las firmas de los métodos son las siguientes:

public boolean isEmpty()
public boolean isBlank()

System.out.println(" ".isEmpty()); // false - tiene un espacio en blanco
System.out.println("".isEmpty()); // true - no hay ningun caracter
System.out.println(" ".isBlank()); // true - no hay caracteres ademas del espacio en blanco.
System.out.println("".isBlank()); // true - no hay caracteres ademas del espacio en blanco.

Formateando Valores:
Hay métodos para formatear valores String usando banderas de formateo. Dos de los métodos toman la cadena de formato como parámetro, y el otro usa una instancia para ese valor.

Los parámetros del método se utilizan para construir una String formateada en una sola llamada al método, en lugar de hacerlo mediante muchas operaciones de formato y concatenación. Devuelven una referencia a la instancia sobre la que se llaman para que las operaciones se puedan encadenar juntas. Las firmas de los métodos son las siguientes:

public static String format(String format, Object args...)
public static String format(Locale loc, String format, Object args...)
public String formatted(Object args...)

var name = "Kate";
var orderId = 5;

// Todos imprimen: Hello Kate, order 5 is ready

System.out.println("Hello "+name+", order "+orderId+" is ready");
System.out.println(String.format("Hello %s, order %d is ready",
    name, orderId));
System.out.println("Hello %s, order %d is ready"
    .formatted(name, orderId));

En las operaciones format() y formatted(), los parámetros se insertan y formatean mediante símbolos en el orden en que se proporcionan en el Vargs.

Formateo comunes:

%s Se aplica a cualquier tipo, comúnmente valores String
%d Se aplica a valores enteros como int y long
%f Se aplica a valores de punto flotante como float y double
%n Inserta un salto de línea usando el separador de línea dependiente del sistema

var name = "James";
var score = 90.25;
var total = 100;

System.out.println("%s:%n Score: %f out of %d".formatted(name, score, total));

la salida es:

James:
Score: 90.250000 out of 100


La mezcla de tipos de datos puede causar excepciones en tiempo de ejecución. Por ejemplo, lo siguiente lanza una excepción porque se usa un número de punto flotante cuando se espera un valor entero:

var str = "Food: %d tons".formatted(2.0);
IllegalFormatConversionException

las banderas ya definidas se pueden ajustar mas; En el ejemplo anterior, el número de punto flotante se imprimió como 90.250000. Por defecto, %f muestra exactamente seis dígitos después del decimal. Si deseas mostrar solo un dígito después del decimal, puedes usar %.1f en lugar de %f. El método format() se basa en el redondeo en lugar de truncar al acortar números.

Por ejemplo, 90.250000 se mostrará como 90.3 (no 90.2) cuando se pase a format() con %.1f.
El método format() también admite dos características adicionales. Puedes especificar la longitud total de la salida usando un número antes del símbolo decimal. Por defecto, el método rellenará el espacio vacío con espacios en blanco. También puedes rellenar el espacio vacío con ceros colocando un solo cero antes del símbolo decimal. Los siguientes ejemplos usan corchetes, [], para mostrar el inicio/fin del valor formateado:

var pi = 3.141592653589;
System.out.format("[%6f]",pi);    // [3.141593]
System.out.format("[%12.8f]",pi);  // [ 3.14159265]
System.out.format("[%012f]",pi);   // [00003.141593]
System.out.format("[%12.2f]",pi);  // [       3.14]
System.out.format("[%.3f]",pi);    // [3.142]

Encadenamiento de Métodos:

var start = "AniMaL ";
var trimmed = start.trim();        // "AniMaL"
var lowercase = trimmed.toLowerCase(); // "animal"
var result = lowercase.replace('a', 'A'); // "AnimAl"
System.out.println(result);

Esto es solo una serie de métodos String. Cada vez que se llama a uno, el valor devuelto se coloca en una nueva variable. Hay cuatro valores String a lo largo del camino, y se muestra AnimAl como salida.
Sin embargo, en el examen, hay una tendencia a comprimir tanto código como sea posible en un espacio pequeño. Verás código usando una técnica llamada "encadenamiento de métodos". Aquí hay un ejemplo:

String result = "AniMaL ".trim().toLowerCase().replace('a', 'A');
System.out.println(result);

Este código es equivalente al ejemplo anterior. También crea cuatro objetos String y muestra AnimAl. Para leer código que usa encadenamiento de métodos, empieza por la izquierda y evaluar el primer método. Luego llamar al siguiente método sobre el valor devuelto por el primer método. Continúa así hasta que llegues al punto y coma.

5: String a = "abc";
6: String b = a.toUpperCase();
7: b = b.replace("B", "2").replace('C', '3');
8: System.out.println("a=" + a);
9: System.out.println("b=" + b);

En la línea 5, establecemos que a apunte a "abc" y nunca apuntó a nada más. Como ninguno del código en las líneas 6 y 7 cambia a, el valor permanece "abc".
Sin embargo, b es un poco más complicado. La línea 6 hace que b apunte a "ABC", lo cual es sencillo. En la línea 7, tenemos encadenamiento de métodos. Primero se llama a "ABC".replace("B", "2"). Esto devuelve "A2C". Luego, se llama a "A2C".replace('C', '3'), lo que devuelve "A23".

Usando la Clase StringBuilder:

10: String alpha = "";
11: for(char current = 'a'; current <= 'z'; current++)
12:   alpha += current;
13: System.out.println(alpha);

La String vacía en la línea 10 se instancia, y luego la línea 12 añade una "a". Sin embargo, como el objeto String es inmutable, se asigna un nuevo objeto String a alpha, y el objeto "" se vuelve elegible para la recolección de basura.
La siguiente vez que se pasa por el bucle, alpha se asigna a un nuevo objeto String "ab", y el objeto "a" se vuelve elegible para la recolección de basura.
La siguiente iteración asigna alpha a "abc", y el objeto "ab" se vuelve elegible para la recolección de basura, y así sucesivamente.

Esta secuencia de eventos continúa, y después de 26 iteraciones a través del bucle, un total de 27 objetos son instanciados, la mayoría de los cuales son inmediatamente elegibles para la recolección de basura.

Esto es muy ineficiente. Afortunadamente, Java tiene una solución. La clase StringBuilder crea una String sin almacenar todos esos valores String intermedios. A diferencia de la clase String, StringBuilder no es inmutable.

15: StringBuilder alpha = new StringBuilder();
16: for(char current = 'a'; current <= 'z'; current++)
17:  alpha.append(current);
18: System.out.println(alpha);

En la línea 15, se instancia un nuevo objeto StringBuilder. La llamada a append() en la línea 17 añade un carácter al objeto StringBuilder cada vez que pasa por el bucle for, añadiendo el valor de current al final de alpha. Este código reutiliza el mismo StringBuilder sin crear una String intermedia cada vez.

Mutabilidad y Encadenamiento:

Seguramente notaste esto del ejemplo anterior, pero StringBuilder no es inmutable. De hecho, le dimos 27 valores diferentes en el ejemplo (un espacio en blanco más cada letra del alfabeto). El examen probablemente intentará engañarte con respecto a la mutabilidad de String y StringBuilder.

El encadenamiento hace esto aún más interesante. Cuando encadenamos llamadas a métodos String, el resultado era una nueva String con la respuesta. El encadenamiento de métodos StringBuilder no funciona así. En su lugar, el StringBuilder cambia su propio estado y devuelve una referencia a sí mismo. Veamos un ejemplo para aclarar esto:

4: StringBuilder sb = new StringBuilder("start");
5: sb.append("+middle"); // sb = "start+middle"
6: StringBuilder same = sb.append("+end"); // "start+middle+end"

La línea 5 añade texto al final de sb. También devuelve una referencia a sb, que se ignora. La línea 6 también añade texto al final de sb y devuelve una referencia a sb. Esta vez la referencia se almacena en same. Esto significa que sb y same apuntan al mismo objeto e imprimirían el mismo valor.

El examen no siempre hará que el código sea fácil de leer teniendo solo un método por línea. ¿Qué crees que imprime este ejemplo?

4: StringBuilder a = new StringBuilder("abc");
5: StringBuilder b = a.append("de");
6: b = b.append("f").append("g");
7: System.out.println("a=" + a);
8: System.out.println("b=" + b);

¿Dijiste que ambos imprimen "abcdefg"? Bien. Solo hay un objeto StringBuilder aquí. Sabemos eso porque new StringBuilder() se llama solo una vez. En la línea 5, en la línea 6, ambas variables siguen apuntando al mismo objeto, que ahora tiene un valor de "abcdefg". Asignar el valor de nuevo a 'b' no tiene ningún efecto, ya que 'b' ya está apuntando a ese mismo StringBuilder.

Creación de un StringBuilder

Hay tres formas de construir un StringBuilder:

StringBuilder sb1 = new StringBuilder();
StringBuilder sb2 = new StringBuilder("animal");
StringBuilder sb3 = new StringBuilder(10);

El primer ejemplo crea un StringBuilder que contiene una secuencia vacía de caracteres y asigna a sb1 para que lo apunte. El segundo crea un StringBuilder que contiene un valor específico y asigna a sb2 para que lo apunte. Los dos primeros ejemplos permiten que Java gestione los detalles de la implementación. El último ejemplo le indica a Java que tenemos alguna idea de cuál será el valor final y que nos gustaría que el StringBuilder reserve una cierta capacidad, o número de espacios, para caracteres.

Metodos comunes de un StringBuilder:

var sb = new StringBuilder("animals");
String sub = sb.substring(sb.indexOf("a"), sb.indexOf("al"));
int len = sb.length();
char ch = sb.charAt(6);
System.out.println(sub + " " + len + " " + ch);


La respuesta correcta es anim 7 s. El método indexOf() devuelve 0 y 4, respectivamente. El método substring() devuelve la cadena que comienza con el índice 0 y termina justo antes del índice 4.

El método length() devuelve 7 porque ese es el número de caracteres en el StringBuilder, en lugar de un índice. Finalmente, charAt() devuelve el carácter en el índice 6. Aquí comenzamos con 0 porque nos referimos a índices.

Nota que substring() devuelve un String en lugar de un StringBuilder. Por eso sb no se modifica. El método substring() es simplemente un método que consulta el estado del StringBuilder.

Agregar valores (Appending Values):

El método append() es, con mucho, el más utilizado en StringBuilder. De hecho, se usa tan frecuentemente que simplemente comenzamos a usarlo sin comentar al respecto. Afortunadamente, este método hace exactamente lo que parece: agrega el parámetro al StringBuilder y devuelve una referencia al StringBuilder actual. Una de las firmas del método es la siguiente:

public StringBuilder append(String str)

var sb = new StringBuilder().append(1).append('c');
sb.append("-").append(true);
System.out.println(sb); // 1c-true

¿Te gusta esta forma de encadenar métodos? El método append() se llama directamente después del constructor. Al contar con todas estas firmas de métodos, puedes simplemente llamar a append() sin necesidad de convertir tu parámetro a un String primero.

Insertar datos (Inserting Data):

El método insert() agrega caracteres al StringBuilder en el índice solicitado y devuelve una referencia al StringBuilder actual. Al igual que append(), existen muchas firmas del método para diferentes tipos. Aquí tienes una:

public StringBuilder insert(int offset, String str)

Presta atención al desplazamiento (offset) en estos ejemplos. Es el índice donde queremos insertar el parámetro solicitado.

var sb = new StringBuilder("animals");
sb.insert(7, "-");   // sb = animals-
sb.insert(0, "-");   // sb = -animals-
sb.insert(4, "-");   // sb = -ani-mals-
System.out.println(sb);

La línea 4 indica insertar un guion (-) en el índice 7, que resulta ser el final de la secuencia de caracteres. La línea 5 indica insertar un guion en el índice 0, que es el principio de la secuencia. Finalmente, la línea 6 inserta un guion justo antes del índice 4.

Eliminando contenido:

El método delete() es lo opuesto al método insert(). Elimina caracteres de la secuencia y devuelve una referencia al StringBuilder actual. Si solo quieres eliminar un carácter, el método deleteCharAt() es más conveniente. Las firmas de estos métodos son las siguientes:

public StringBuilder delete(int startIndex, int endIndex)
public StringBuilder deleteCharAt(int index)

El siguiente código muestra cómo usar estos métodos:

var sb = new StringBuilder("abcdef");
sb.delete(1, 3); // sb = adef
sb.deleteCharAt(5); // excepción

Primero, eliminamos los caracteres comenzando desde el índice 1 y terminando justo antes del índice 3. Esto nos da "adef". Luego, le pedimos a Java que elimine el carácter en la posición 5. Sin embargo, el valor restante solo tiene cuatro caracteres de longitud, por lo que lanza una excepción StringIndexOutOfBoundsException.

Reemplazando Porciones:

El método replace() funciona de manera diferente para StringBuilder en comparación con String. La firma del método es la siguiente:

public StringBuilder replace(int startIndex, int endIndex, String newString)

var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 6, "sty");
System.out.println(builder); // pigsty dirty

Primero, Java elimina los caracteres comenzando desde el índice 3 y terminando justo antes del índice 6. Esto nos da "pig dirty". Luego, Java inserta el valor "sty" en esa posición.

En este ejemplo, el número de caracteres que eliminamos y los que insertamos son iguales. Sin embargo, no hay ninguna razón obligatoria para que esto sea así. ¿Qué crees que hace este código?

var builder = new StringBuilder("pigeon dirty");
builder.replace(3, 100, "");
System.out.println(builder);

Imprime "pig". Recuerda, el método realiza primero una eliminación lógica. El método replace() permite especificar un segundo parámetro que excede el final del StringBuilder.

Invertir (Reversing):

Después de todo esto, es hora de un método fácil. El método reverse() hace exactamente lo que parece: invierte los caracteres en la secuencia y devuelve una referencia al StringBuilder actual. La firma del método es la siguiente:

public StringBuilder reverse()

var sb = new StringBuilder("ABC");
sb.reverse();
System.out.println(sb);

El resultado será "CBA". Este método no es muy interesante. Tal vez los creadores del examen lo incluyan para animarte a escribir el valor en lugar de confiar en la memoria para los índices.

Trabajando con toString()

La clase Object contiene un método toString() que muchas clases proporcionan como implementación personalizada. La clase StringBuilder es una de estas.

El siguiente código muestra cómo usar este método:

var sb = new StringBuilder("ABC");
String s = sb.toString();

A menudo, StringBuilder se usa internamente por razones de rendimiento, pero el resultado final necesita ser una cadena (String). Por ejemplo, tal vez se necesite pasar el valor a otro método que espera un String.

Entendiendo la igualdad (Understanding Equality):

En el Capítulo 2, aprendiste a usar == para comparar números y que las referencias de objetos apuntan al mismo objeto. En esta sección, analizamos lo que significa para StringBuilder.

En Java, para determinar si dos objetos son iguales, no solo basta con comparar sus referencias en memoria (usando el operador ==). A veces, necesitamos comparar el contenido de esos objetos. Esto es especialmente relevante cuando hablamos de clases como String y StringBuilder.

Java tiene una característica llamada "String Pool". Cuando creas un objeto String con una cadena literal (entre comillas dobles), Java busca en el String Pool para ver si ya existe un objeto String con ese mismo valor. Si lo encuentra, te devuelve una referencia a ese objeto existente en lugar de crear uno nuevo. Esto ayuda a ahorrar memoria y mejorar el rendimiento.

var x = "Hello World";
var z = "Hello World".trim();
System.out.println(x.equals(z)); // true

Comparando equals() y ==

==: Compara las referencias de los objetos. Si dos referencias apuntan al mismo objeto en memoria, == devuelve true.

equals(): Compara el contenido de los objetos. La implementación de equals() varía según la clase. Para las clases envolventes (Integer, Double, etc.) y String, equals() compara el valor.

var one = new StringBuilder();
var two = new StringBuilder();
var three = one.append("a");

System.out.println(one == two); // false - one y two son objetos diferentes
System.out.println(one == three); // true - three es una referencia al mismo objeto que one después de llamar a append()

StringBuilder y equals()

StringBuilder no sobreescribe el método equals() para comparar el contenido. Por defecto, equals() en StringBuilder compara las referencias.
Si quieres comparar el contenido de dos StringBuilder, debes convertirlos a String usando toString() y luego comparar los String.

var name = "a";
var builder = new StringBuilder("a");
System.out.println(name == builder); // DOES NOT COMPILE

Este código no compila porque estás intentando comparar un String con un StringBuilder. Java no puede comparar directamente objetos de tipos diferentes.

El Pool de Cadenas (String Pool)

Dado que las cadenas (strings) están presentes en todas partes en Java, consumen una gran cantidad de memoria. En algunas aplicaciones de producción, pueden ocupar una gran porción de la memoria total del programa. Java reconoce que muchas cadenas se repiten en el programa y resuelve este problema reutilizando las comunes. El pool de cadenas (también conocido como el intern pool) es una ubicación en la Máquina Virtual de Java (JVM) que almacena todas estas cadenas.

El pool de cadenas contiene valores literales y constantes que aparecen en tu programa. Por ejemplo, "nombre" es un literal y, por lo tanto, entra en el pool de cadenas. El método myObject.toString() devuelve una cadena pero no un literal, así que no entra en el pool.

var x = "Hello World";
var y = "Hello World";
System.out.println(x == y); // true

Dado que las cadenas son inmutables y los literales se almacenan en el pool, la JVM crea solo una ubicación en memoria para el literal. Por lo tanto, las variables x e y apuntan al mismo lugar en memoria; por lo tanto, la instrucción imprime true.

var x = "Hello World";
var y = new String("Hello World");
System.out.println(x == y); // false

La primera línea utiliza el pool de cadenas normalmente. La segunda línea dice: "No, JVM, realmente no quiero que uses el pool de cadenas. Por favor, crea un nuevo objeto para mí, aunque sea menos eficiente".

Utilizando el método intern():

También puedes decirle a Java que use el pool de cadenas. El método intern() utilizará un objeto en el pool de cadenas si ya existe uno presente.

public String intern()

var name = "Hello World";
var name2 = new String("Hello World").intern();
System.out.println(name == name2); // true

Primero, le decimos a Java que use el pool de cadenas normalmente para name. Luego, para name2, le decimos que cree un nuevo objeto usando el constructor pero que lo interné y use el pool de cadenas de todos modos. Dado que ambas variables apuntan a la misma referencia en el pool de cadenas, podemos usar el operador ==.

15| var first = "rat" + 1;
16| var second = "r" + "a" + "t" + "1";
17| var third = "r" + "a" + "t" + new String("1");

18| System.out.println(first == second);
19| System.out.println(first == second.intern());
20| System.out.println(first == third);
21| System.out.println(first == third.intern());

Líneas 15 y 16: Ambas son constantes en tiempo de compilación y se colocan automáticamente en el pool de cadenas.

Línea 17: Aquí tenemos un constructor de String. Esto significa que ya no tenemos una constante en tiempo de compilación y third no hace referencia a una llamada en el pool de cadenas.

Líneas 18 y 19: La línea 18 es false porque third no está en el pool. La línea 19 es true porque intern() busca en el pool de cadenas y encuentra que first apunta a la misma cadena.

Línea 20 imprime falso

Arreglos:

Hasta ahora, nos hemos referido a las clases String y StringBuilder como una "secuencia de caracteres". Esto es cierto. Están implementadas usando un arreglo de caracteres. Un arreglo es un área de memoria en el heap con espacio para un número designado de elementos. Un String se implementa como un arreglo con algunas métodos que te pueden ser útiles cuando estás tratando con caracteres específicamente. Un StringBuilder es implementado usando un arreglo donde el objeto del arreglo es reemplazado con uno nuevo, más grande cuando se queda sin espacio para almacenar los caracteres. A diferencia de un String, un arreglo puede ser de cualquier otro tipo de Java. Si no quieres usar un String por alguna razón, podrías usar un arreglo de char primitivos directamente:

char[] letters;

Esto no sería muy conveniente porque perderíamos todas las propiedades especiales que String nos da, como escribir "Java".  Mantén en mente que letters es una variable de referencia y no un primitivo. El tipo char es un primitivo. Pero char es lo que va dentro del arreglo y no el tipo del arreglo en sí. El arreglo en sí es de tipo char[].

Creando un Arreglo de Primitivos

int[] numbers = new int[3];

Cuando usas este formulario para instanciar un arreglo, todos los elementos se establecen en el valor por defecto para ese tipo. Como aprendiste en el Capítulo 1, el valor por defecto de un int es 0.  En la Figura 4.4, puedes ver que el valor por defecto para todos los elementos es 0. También, los índices comienzan con 0 y cuentan hacia arriba, así como lo hacían para un String.

Cuando usas este formulario para instanciar un arreglo, todos los elementos se establecen en el valor por defecto para ese tipo. Como aprendiste en el Capítulo 1, el valor por defecto de un int es 0 (imagen02)

int[] moreNumbers = new int[] {42, 55, 99};

En este ejemplo, también creamos un arreglo de enteros de tamaño 3. Esta vez, especificamos los valores iniciales de esos tres elementos en lugar de usar los valores predeterminados.

Java reconoce que esta expresión es redundante. Dado que estás especificando el tipo del arreglo en el lado izquierdo del signo igual, Java ya sabe el tipo. Y dado que estás especificando los valores iniciales, ya sabe el tamaño. Como un atajo, Java te permite escribir esto:

int[] moreNumbers = {42, 55, 99};

Este enfoque se llama un arreglo anónimo. Es anónimo porque no especificas el tipo y el tamaño.

Finalmente, puedes escribir los corchetes ([]) antes o después del nombre, y agregar un espacio es opcional. por ejemplo, lo siguiente es valido:

int[] numA1;
int [] numA1;
int []numA1;
int numA1[];
int numA1 [];

¿Qué tipos de variables de referencia crees que crea el siguiente código?

int[] ids, types;

La respuesta correcta es que crea dos variables de tipo int[]

int ids[], types;

La primera se llama ids[]. Esta es un arreglo de int, llamada ids. La segunda es solo llamada types. No tiene corchetes, así que es un entero regular



